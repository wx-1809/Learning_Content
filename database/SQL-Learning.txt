
1.查找最晚入职员工的所有信息
    描述：有一个员工employees表简况如下:
        select * from employees where hire_date=(select max(hire_date) from employees);


2.查找倒数第三员工的所有信息
    select * from employees where hire_date=(
        select distinct hire_date from employees
            order by hire_date desc limit 1 offset 2)
    其中limit 1,offset 2：表示去掉排名倒数第一第二的时间，取倒数第三的时间；

    select * from test LIMIT 3 OFFSET 1;(在mysql 5以后支持这种写法)
    当 limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量。

3.请你查找各个部门当前领导的薪水详情以及其对应部门编号dept_no，输出结果以salaries.emp_no升序排序，并且请注意输出结果里面dept_no列是最后一列；
    select salaries.emp_no, salaries.salary, salaries.from_date, salaries.to_date, dept_manager.dept_no
    from salaries,dept_manager
        where salaries.emp_no=dept_manager.emp_no
            order by salaries.emp_no


4.请你查找所有已经分配部门的员工的last_name和first_name以及dept_no，未分配的部门的员工不显示；
   select employees.last_name,employees.first_name,dept_emp.dept_no
    from employees,dept_emp
        where employees.emp_no=dept_emp.emp_no

5.请你查找所有已经分配部门的员工的last_name和first_name以及dept_no，也包括暂时没有分配具体部门的员工；
    (1)左连接：
        以左表为基础，根据on后给出的两表的条件将两表连接起来，结果会将左表所有的查询信息列出，而右边只列出on后条件与左表满足的部分。
        左表(table 1)全部保留,右表(table 2)关联不上用null表示。
        SELECT * FROM table1 LEFT JOIN table2 ON table1.a=table2.b
    (2)右连接：
        与左连接相反。
        右表(table2)全部保留，左表(table1)关联不上的用null表示。
        SELECT * FROM table1 RIGHT JOIN table2 ON table1.a=table2.b
    (3)内连接：
        保留两个表共有的部分。
        SELECT * FROM table1 inner JOIN table2 ON table1.a=table2.b

    select last_name, first_name, dept_no from employees left join dept_emp
        on employees.emp_no=dept_emp.emp_no

6.请你查找薪水记录超过15条的员工号emp_no以及其对应的记录次数t，内容如下：--牛客网SQL7
    select emp_no, count(emp_no) as t from salaries
        group by emp_no having t>15;

    group by和having一起使用；

7.请你找出所有员工具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示，以上例子输出如下：---牛客网SQL8
    select salary from salaries
        group by salary
            order by salary desc

    需要注意的点：
        1.相同的薪水只显示一次：使用group by实现
        2.逆序显示：order by 名称 desc

8.获取所有非manager的员工emp_no----牛客网SQL10
    请你找出所有非部门领导的员工emp_no，以上例子输出:

    NOT IN+子查询
    select emp_no from employees as e
        where emp_no not in (select emp_no from dept_manager)

    left join 左连接+is null
        select e.emp_no from employees as e
            left join dept_manager as d
                on e.emp_no = d.emp_no
                    where dept_no is NULL;


9.获取所有的员工和员工对应的经理，如果员工本身是经理的话则不显示，以上例子如下:
    select e.emp_no, m.emp_no from dept_emp as e inner join dept_manager as m
      on e.dept_no = m.dept_no
       where e.emp_no!=m.emp_no


10.获取每个部门中当前员工薪水最高的相关信息----SQL12  （需要重点分析）
    获取每个部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary，按照部门编号dept_no升序排列，以上例子输出如下:
     SELECT
        e.dept_no,
        e.emp_no,
        maxSalary
    FROM
        dept_emp e
        INNER JOIN salaries s ON e.emp_no = s.emp_no
        INNER JOIN (
        SELECT
            e.dept_no,
            max( s.salary ) AS maxSalary
        FROM
            dept_emp e
            INNER JOIN salaries s ON e.emp_no = s.emp_no
        GROUP BY
            e.dept_no
        ) AS m ON e.dept_no = m.dept_no
        AND s.salary = m.maxSalary
    ORDER BY
        e.dept_no


11.查找employees表emp_no与last_name的员工信息---SQL15
    请你查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列，以上例子查询结果如下:
     select emp_no,birth_date,first_name,last_name,gender,hire_date from employees
        where emp_no % 2 = 1
        and last_name<>'Mary'
        order by hire_date desc;
    注：
        1.不等于：”<>“;
        2.基数：emp % 2 =1


12.统计出当前各个title类型对应的员工当前薪水对应的平均工资---SQL16
    请你统计出各个title类型对应的员工薪水对应的平均工资avg。结果给出title以及平均工资avg，并且以avg升序排序，以上例子输出如下:
        select t.title, avg(s.salary) from titles as t inner join salaries as s
            on t.emp_no=s.emp_no
             group by t.title

    注：内连接，将相同的字段处理相同，然后分组；求平均值

13.获取当前薪水第二多的员工的emp_no以及其对应的薪水salary---SQL17
    请你获取薪水第二多的员工的emp_no以及其对应的薪水salary，
       若有多个员工的薪水为第二多的薪水，则将对应的员工的emp_no和salary全部输出，并按emp_no升序排序。
            select emp_no,salary from salaries
              where salary = (select distinct salary from salaries
                order by salary desc limit 1,1 ) ;

        注：第二员工最多的使用limit；distinct筛选出相应的内容；

14.获取当前薪水第二多的员工的emp_no以及其对应的薪水salary---SQL18
    请你查找薪水排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不能使用order by完成，以上例子输出为:
      （温馨提示:sqlite通过的代码不一定能通过mysql，因为SQL语法规定，使用聚合函数时，select子句中一般只能存在以下三种元素：常数、聚合函数，group by 指定的列名。如果使用非group by的列名，sqlite的结果和mysql 可能不一样)
        select e.emp_no emp_no,s.salary salary,e.last_name last_name,e.first_name first_name
          from employees as e
            inner join salaries as s
             on e.emp_no = s.emp_no and s.to_date='9999-01-01'
              where s.salary=(
                select max(s2.salary)
                 from salaries s2
                 where
                    s2.salary < (select max(salary) from salaries where to_date='9999-01-01')
                   and s2.to_date='9999-01-01'
             );

        注：第二大<最大值，以此筛选出第二多的员工

15.查找所有员工的last_name和first_name以及对应的dept_name---SQL19
    请你查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工，以上例子输出如下:

    先内连接筛选出dept_no和emp_no的内容，然后于employee的表左外连接，即可得到最终的筛选内容：
        （1）select d.dept_name, dp.emp_no from departments as d inner join dept_emp as dp on
            d.dept_no = dp.dept_no
        （2）左外连接得到最终的结果：
            SELECT e.last_name, e.first_name, b.dept_name FROM employees AS e
                LEFT JOIN (SELECT d.dept_name,de.emp_no
                  FROM departments AS d
                   INNER JOIN dept_emp AS de
                    ON d.dept_no=de.dept_no
                   ) AS b
                ON e.emp_no=b.emp_no;

16.查找在职员工自入职以来的薪水涨幅情况：----SQL21
    请你查找在职员工自入职以来的薪水涨幅情况，给出在职员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序，以上例子输出为
    （注: to_date为薪资调整某个结束日期，或者为离职日期，to_date='9999-01-01'时，表示依然在职，无后续调整记录）






































